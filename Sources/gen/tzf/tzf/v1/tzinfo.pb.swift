// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tzf/v1/tzinfo.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Tzf_V1_CompressMethod: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unspecified // = 0

  /// https://developers.google.com/maps/documentation/utilities/polylinealgorithm
  case polyline // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .polyline
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .polyline: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Tzf_V1_CompressMethod] = [
    .unspecified,
    .polyline,
  ]

}

/// Basic point data define.
struct Tzf_V1_Point: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lng: Float = 0

  var lat: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Define a polygon, mostly based on GeoJSON's Polygon define.
///
/// Excerpt from RFC-9476 section 'Polygon'
///
///   -  A linear ring is a closed LineString with four or more positions.
///   -  The first and last positions are equivalent, and they MUST contain
///     identical values; their representation SHOULD also be identical.
///   -  A linear ring is the boundary of a surface or the boundary of a
///     hole in a surface.
///   -  A linear ring MUST follow the right-hand rule with respect to the
///     area it bounds, i.e., exterior rings are counterclockwise, and
///     holes are clockwise.
///
///   Note: the [GJ2008] specification did not discuss linear ring winding
///   order.  For backwards compatibility, parsers SHOULD NOT reject
///   Polygons that do not follow the right-hand rule.
///
///   Though a linear ring is not explicitly represented as a GeoJSON
///   geometry type, it leads to a canonical formulation of the Polygon
///   geometry type definition as follows:
///
///   -  For type "Polygon", the "coordinates" member MUST be an array of
///     linear ring coordinate arrays.
///   -  For Polygons with more than one of these rings, the first MUST be
///     the exterior ring, and any others MUST be interior rings.  The
///     exterior ring bounds the surface, and the interior rings (if
///     present) bound holes within the surface.
///
/// [GJ2008]: https://geojson.org/geojson-spec
struct Tzf_V1_Polygon: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// define the "exterior ring"
  var points: [Tzf_V1_Point] = []

  /// define the "interior rings" as holes
  var holes: [Tzf_V1_Polygon] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Timezone is a timezone's all data.
struct Tzf_V1_Timezone: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var polygons: [Tzf_V1_Polygon] = []

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tzf_V1_Timezones: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timezones: [Tzf_V1_Timezone] = []

  /// Reduced data will toggle neighbor search as plan b
  var reduced: Bool = false

  var version: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tzf_V1_CompressedPolygon: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var points: Data = Data()

  var holes: [Tzf_V1_CompressedPolygon] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CompressedTimezonesItem designed for binary file as small as possible.
struct Tzf_V1_CompressedTimezone: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: [Tzf_V1_CompressedPolygon] = []

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tzf_V1_CompressedTimezones: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var method: Tzf_V1_CompressMethod = .unspecified

  var timezones: [Tzf_V1_CompressedTimezone] = []

  var version: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PreindexTimezone tile item.
///
/// The X/Y/Z are OSM style like map tile index values.
struct Tzf_V1_PreindexTimezone: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var x: Int32 = 0

  var y: Int32 = 0

  var z: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PreindexTimezones is all preindex timezone's dumps.
struct Tzf_V1_PreindexTimezones: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// which zoom value the tiles generated
  var idxZoom: Int32 = 0

  /// which zoom value the tiles merge up with.
  var aggZoom: Int32 = 0

  var keys: [Tzf_V1_PreindexTimezone] = []

  var version: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tzf.v1"

extension Tzf_V1_CompressMethod: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMPRESS_METHOD_UNSPECIFIED"),
    1: .same(proto: "COMPRESS_METHOD_POLYLINE"),
  ]
}

extension Tzf_V1_Point: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Point"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lng"),
    2: .same(proto: "lat"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.lng) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.lat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lng.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.lng, fieldNumber: 1)
    }
    if self.lat.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.lat, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tzf_V1_Point, rhs: Tzf_V1_Point) -> Bool {
    if lhs.lng != rhs.lng {return false}
    if lhs.lat != rhs.lat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tzf_V1_Polygon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Polygon"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
    2: .same(proto: "holes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.points) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.holes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.points.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.points, fieldNumber: 1)
    }
    if !self.holes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.holes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tzf_V1_Polygon, rhs: Tzf_V1_Polygon) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs.holes != rhs.holes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tzf_V1_Timezone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Timezone"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "polygons"),
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.polygons) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.polygons.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.polygons, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tzf_V1_Timezone, rhs: Tzf_V1_Timezone) -> Bool {
    if lhs.polygons != rhs.polygons {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tzf_V1_Timezones: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Timezones"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timezones"),
    2: .same(proto: "reduced"),
    3: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.timezones) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.reduced) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.timezones.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.timezones, fieldNumber: 1)
    }
    if self.reduced != false {
      try visitor.visitSingularBoolField(value: self.reduced, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tzf_V1_Timezones, rhs: Tzf_V1_Timezones) -> Bool {
    if lhs.timezones != rhs.timezones {return false}
    if lhs.reduced != rhs.reduced {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tzf_V1_CompressedPolygon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CompressedPolygon"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
    2: .same(proto: "holes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.points) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.holes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.points.isEmpty {
      try visitor.visitSingularBytesField(value: self.points, fieldNumber: 1)
    }
    if !self.holes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.holes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tzf_V1_CompressedPolygon, rhs: Tzf_V1_CompressedPolygon) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs.holes != rhs.holes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tzf_V1_CompressedTimezone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CompressedTimezone"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tzf_V1_CompressedTimezone, rhs: Tzf_V1_CompressedTimezone) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tzf_V1_CompressedTimezones: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CompressedTimezones"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "method"),
    2: .same(proto: "timezones"),
    3: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.method) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.timezones) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.method != .unspecified {
      try visitor.visitSingularEnumField(value: self.method, fieldNumber: 1)
    }
    if !self.timezones.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.timezones, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tzf_V1_CompressedTimezones, rhs: Tzf_V1_CompressedTimezones) -> Bool {
    if lhs.method != rhs.method {return false}
    if lhs.timezones != rhs.timezones {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tzf_V1_PreindexTimezone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PreindexTimezone"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "x"),
    3: .same(proto: "y"),
    4: .same(proto: "z"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.x) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.y) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.z) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.x != 0 {
      try visitor.visitSingularInt32Field(value: self.x, fieldNumber: 2)
    }
    if self.y != 0 {
      try visitor.visitSingularInt32Field(value: self.y, fieldNumber: 3)
    }
    if self.z != 0 {
      try visitor.visitSingularInt32Field(value: self.z, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tzf_V1_PreindexTimezone, rhs: Tzf_V1_PreindexTimezone) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tzf_V1_PreindexTimezones: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PreindexTimezones"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "idx_zoom"),
    2: .standard(proto: "agg_zoom"),
    3: .same(proto: "keys"),
    4: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.idxZoom) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.aggZoom) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.keys) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.idxZoom != 0 {
      try visitor.visitSingularInt32Field(value: self.idxZoom, fieldNumber: 1)
    }
    if self.aggZoom != 0 {
      try visitor.visitSingularInt32Field(value: self.aggZoom, fieldNumber: 2)
    }
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 3)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tzf_V1_PreindexTimezones, rhs: Tzf_V1_PreindexTimezones) -> Bool {
    if lhs.idxZoom != rhs.idxZoom {return false}
    if lhs.aggZoom != rhs.aggZoom {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
